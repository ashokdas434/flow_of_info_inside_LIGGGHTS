cfd_datacoupling_file.cpp:                                                   "Note that file-based coupling currently does not support inserting or deleting particles during a coupled run.");
cfd_datacoupling_file.cpp:                                                   "Note that file-based coupling currently does not support inserting or deleting particles during a coupled run.");
citeme.cpp:  cs->insert(ref);
comm.cpp:#include "fix_insert.h"
compute.cpp:  // i = location in list to insert ntimestep
compute.cpp:  // move remainder of list upward and insert ntimestep
create_atoms.cpp:  //   thus insertion box is EPSILON smaller than true box
dump_local_gran.cpp:    vector_set.insert(X1);
dump_local_gran.cpp:    vector_set.insert(X2);
dump_local_gran.cpp:            vector_set.insert(CP);
dump_local_gran.cpp:            vector_set.insert(V1);
dump_local_gran.cpp:            vector_set.insert(V2);
dump_local_gran.cpp:            vector_set.insert(F);
dump_local_gran.cpp:            vector_set.insert(FN);
dump_local_gran.cpp:            vector_set.insert(FT);
dump_local_gran.cpp:            vector_set.insert(TORQUE);
dump_local_gran.cpp:            vector_set.insert(TORQUEN);
dump_local_gran.cpp:            vector_set.insert(TORQUET);
dump_particle.cpp:    vector_set.insert(X); // required
dump_particle.cpp:            vector_set.insert(vector3_starts[v3s]);
dump_particle.cpp:                vector_set.insert(it->first);
fix_continuum_weighted.cpp:            i_contacts.insert(tag[j]);
fix_continuum_weighted.cpp:                        skip_contacts.insert(tag_l);
fix_insert.cpp:#include "fix_insert.h"
fix_insert.cpp:        error->fix_error(FLERR,this,"Fix insert requires you to define a valid ID for a fix of type particledistribution/discrete");
fix_insert.cpp:        ninsert_exists = 0;
fix_insert.cpp:      else ninsert = atof(arg[iarg+1]);
fix_insert.cpp:        ninsert_exists = 0;
fix_insert.cpp:      else massinsert = atof(arg[iarg+1]);
fix_insert.cpp:    } else if (strcmp(arg[iarg],"insert_every_time") == 0 || strcmp(arg[iarg],"insert_every") == 0 || strcmp(arg[iarg],"every") == 0) {
fix_insert.cpp:      if(strcmp(arg[iarg+1],"once") == 0) insert_every = 0;
fix_insert.cpp:      else if(strcmp(arg[iarg],"insert_every_time") == 0)
fix_insert.cpp:          insert_every = static_cast<int>(atof(arg[iarg+1])/update->dt);
fix_insert.cpp:          insert_every = atoi(arg[iarg+1]);
fix_insert.cpp:      if(insert_every < 0) error->fix_error(FLERR,this,"insert_every must be >= 0");
fix_insert.cpp:          v_insert[0] = atof(arg[iarg+2]);
fix_insert.cpp:          v_insert[1] = atof(arg[iarg+3]);
fix_insert.cpp:          v_insert[2] = atof(arg[iarg+4]);
fix_insert.cpp:          v_insert[0] = atof(arg[iarg+2]);
fix_insert.cpp:          v_insert[1] = atof(arg[iarg+3]);
fix_insert.cpp:          v_insert[2] = atof(arg[iarg+4]);
fix_insert.cpp:          v_insertFluct[0] = atof(arg[iarg+5]);
fix_insert.cpp:          v_insertFluct[1] = atof(arg[iarg+6]);
fix_insert.cpp:          v_insertFluct[2] = atof(arg[iarg+7]);
fix_insert.cpp:          v_insert[0] = atof(arg[iarg+2]);
fix_insert.cpp:          v_insert[1] = atof(arg[iarg+3]);
fix_insert.cpp:          v_insert[2] = atof(arg[iarg+4]);
fix_insert.cpp:          v_insertFluct[0] = atof(arg[iarg+5]);
fix_insert.cpp:          v_insertFluct[1] = atof(arg[iarg+6]);
fix_insert.cpp:          v_insertFluct[2] = atof(arg[iarg+7]);
fix_insert.cpp:          omega_insert[0] = atof(arg[iarg+2]);
fix_insert.cpp:          omega_insert[1] = atof(arg[iarg+3]);
fix_insert.cpp:          omega_insert[2] = atof(arg[iarg+4]);
fix_insert.cpp:          quat_insert[0] = atof(arg[iarg++]);
fix_insert.cpp:          quat_insert[1] = atof(arg[iarg++]);
fix_insert.cpp:          quat_insert[2] = atof(arg[iarg++]);
fix_insert.cpp:          quat_insert[3] = atof(arg[iarg++]);
fix_insert.cpp:    else if(strcmp(style,"insert") == 0) error->fix_error(FLERR,this,"unknown keyword");
fix_insert.cpp:  ninsert_this_max_local = 0;
fix_insert.cpp:  //min/max type to be inserted, need that to check if material properties defined for all materials
fix_insert.cpp:  // calc max insertion radius
fix_insert.cpp:fprintf(screen,"Fix_insert is being used \n");
fix_insert.cpp:  // calculate ninsert, insert_every, ninsert_per
fix_insert.cpp:  calc_insertion_properties();
fix_insert.cpp:  // calc last step of insertion
fix_insert.cpp:  if(ninsert_exists)
fix_insert.cpp:      if(ninsert <= ninsert_per)
fix_insert.cpp:                static_cast<int>(static_cast<double>(ninsert)/ninsert_per) *  static_cast<double>(insert_every);
fix_insert.cpp:        error->fix_error(FLERR,this,"Particle insertion: Overflow - need too long for particle insertion. "
fix_insert.cpp:                                    "Please decrease # particles to insert or increase insertion rate");
fix_insert.cpp:      if(ninsert < 0)
fix_insert.cpp:        error->fix_error(FLERR,this,"Particle insertion: Overflow - too many particles for particle insertion. "
fix_insert.cpp:                                    "Please decrease # particles to insert.");
fix_insert.cpp:  // default is that total # of particles to insert by this command is known
fix_insert.cpp:  ninsert_exists = 1;
fix_insert.cpp:  ninsert = ninserted = 0;
fix_insert.cpp:  massinsert = massinserted = 0.;
fix_insert.cpp:  insert_every = -1;
fix_insert.cpp:  ninsert_per = 0.;
fix_insert.cpp:  // 1st insertion on next timestep is default
fix_insert.cpp:  vectorZeroize3D(v_insert);
fix_insert.cpp:  vectorZeroize3D(v_insertFluct);
fix_insert.cpp:  vectorZeroize3D(omega_insert);
fix_insert.cpp:  quatIdentity4D(quat_insert);
fix_insert.cpp:    if(MathExtraLiggghts::abs(vectorMag4DSquared(quat_insert)-1.) > 1e-10)
fix_insert.cpp:    if(ninsert > 0 && massinsert > 0.)
fix_insert.cpp:    if(insert_every == 0 && (massflowrate > 0. || nflowrate > 0.))
fix_insert.cpp:        error->fix_error(FLERR,this,"must not define 'particlerate' or 'massrate' for 'insert_every' = 0");
fix_insert.cpp:            seeds.push_back(fix_distribution->particletemplates()[itemplate]->random_insertion_state());
fix_insert.cpp:            sprintf(errstr,"Fix %s, ID %s: Random number generation: It is required that all the random seeds of this fix insert/*, \n"
fix_insert.cpp:    if(ninsert_exists)
fix_insert.cpp:            fprintf(screen ,"INFO: Particle insertion %s: %f particles every %d steps - particle rate %f  (mass rate %e)\n"
fix_insert.cpp:                id,ninsert_per,insert_every,nflowrate,massflowrate,ninsert,massinsert,final_ins_step-first_ins_step);
fix_insert.cpp:            fprintf(logfile,"INFO: Particle insertion %s: %f particles every %d steps - particle rate %f, (mass rate %e)\n"
fix_insert.cpp:                id,ninsert_per,insert_every,nflowrate,massflowrate,ninsert,massinsert,final_ins_step-first_ins_step);
fix_insert.cpp:            fprintf(screen ,"INFO: Particle insertion %s: %f particles every %d steps - particle rate %f  (mass rate %e)\n",
fix_insert.cpp:                id,ninsert_per,insert_every,nflowrate,massflowrate);
fix_insert.cpp:            fprintf(logfile,"INFO: Particle insertion %s: %f particles every %d steps - particle rate %f, (mass rate %e)\n",
fix_insert.cpp:                id,ninsert_per,insert_every,nflowrate,massflowrate);
fix_insert.cpp:            fprintf(screen ,"INFO: Particle insertion %s: inserting every %d steps\n",id,insert_every);
fix_insert.cpp:            fprintf(logfile ,"INFO: Particle insertion %s: inserting every %d steps\n",id,insert_every);
fix_insert.cpp:void FixInsert::print_stats_during(int ninsert_this, double mass_inserted_this)
fix_insert.cpp:      fprintf(screen ,"INFO: Particle insertion %s: inserted %d particle templates (mass %e) at step " BIGINT_FORMAT "\n"
fix_insert.cpp:                      " - a total of %d particle templates (mass %e) inserted so far.\n",
fix_insert.cpp:              id,ninsert_this,mass_inserted_this,step,ninserted,massinserted);
fix_insert.cpp:      fprintf(logfile,"INFO: Particle insertion %s: inserted %d particle templates (mass %e) at step " BIGINT_FORMAT "\n"
fix_insert.cpp:                      " - a total of %d particle templates (mass %e) inserted so far.\n",
fix_insert.cpp:              id,ninsert_this,mass_inserted_this,step,ninserted,massinserted);
fix_insert.cpp:        error->fix_error(FLERR,this,"Fix insert requires atom attributes radius, rmass");
fix_insert.cpp:        error->fix_error(FLERR,this,"Can use fix insert for 3d simulations only");
fix_insert.cpp:    // in case of new fix insert in a restarted simulation, have to add current time-step
fix_insert.cpp:int FixInsert::calc_ninsert_this()
fix_insert.cpp:  if(ninsert_per == 0.) error->fix_error(FLERR,this,"ninsert_per == 0.");
fix_insert.cpp:  // number of bodies to insert this timestep
fix_insert.cpp:  int ninsert_this = static_cast<int>(ninsert_per + random->uniform());
fix_insert.cpp:  if (ninsert_exists && ninserted + ninsert_this > ninsert) ninsert_this = ninsert - ninserted;
fix_insert.cpp:  return ninsert_this;
fix_insert.cpp:   perform particle insertion
fix_insert.cpp:  int ninsert_this, ninsert_this_local; // global and local # bodies to insert this time-step
fix_insert.cpp:  // things to be done before inserting new particles
fix_insert.cpp:  if(!pre_insert())
fix_insert.cpp:  // number of particles to insert this timestep
fix_insert.cpp:  ninsert_this = calc_ninsert_this();
fix_insert.cpp:  // limit to max number of particles that shall be inserted
fix_insert.cpp:  if (ninsert_exists && ninserted + ninsert_this >= ninsert)
fix_insert.cpp:      ninsert_this = ninsert - ninserted;
fix_insert.cpp:      if(ninsert_this < 0)
fix_insert.cpp:        ninsert_this = 0;
fix_insert.cpp:  // distribute ninsert_this across processors
fix_insert.cpp:  ninsert_this_local = distribute_ninsert_this(ninsert_this);
fix_insert.cpp:  if(ninsert_this_local > ninsert_this_max_local)
fix_insert.cpp:      init_list(ninsert_this_local);
fix_insert.cpp:      ninsert_this_max_local = ninsert_this_local;
fix_insert.cpp:  // generate list of insertions
fix_insert.cpp:  // number of inserted particles can change if exact_number = 0
fix_insert.cpp:  ninsert_this_local = generate_list(ninsert_this_local,groupbit,exact_number);
fix_insert.cpp:  MPI_Sum_Scalar(ninsert_this_local,ninsert_this,world);
fix_insert.cpp:  if(ninsert_this == 0)
fix_insert.cpp:        error->warning(FLERR,"Particle insertion: Inserting no particle - check particle insertion settings");
fix_insert.cpp:      // schedule next insertion
fix_insert.cpp:      if (insert_every && (!ninsert_exists || ninserted < ninsert))
fix_insert.cpp:        next_reneighbor += insert_every;
fix_insert.cpp:      else if(0 == insert_every)
fix_insert.cpp:  else if(ninsert_this < 0)
fix_insert.cpp:      error->fix_error(FLERR,this,"Particle insertion: Internal error");
fix_insert.cpp:      sprintf(msg,"Particle insertion on proc %d: sub-domain is smaller than the bounding radius of insert particles to insert: \nMax. bounding "
fix_insert.cpp:  // warn if max # insertions exceeded by random processes
fix_insert.cpp:  if (ninsert_exists && ninserted + ninsert_this > ninsert)
fix_insert.cpp:      error->warning(FLERR,"INFO: Particle insertion: Number of particles to insert was slightly exceeded by random process");
fix_insert.cpp:  // add particles in insertion volume to xnear list
fix_insert.cpp:    load_xnear(ninsert_this_local);
fix_insert.cpp:  // insertion counters in this step
fix_insert.cpp:  int ninserted_this = 0, ninserted_spheres_this = 0;
fix_insert.cpp:  int ninserted_this_local = 0, ninserted_spheres_this_local = 0;
fix_insert.cpp:  double mass_inserted_this = 0.;
fix_insert.cpp:  double mass_inserted_this_local = 0.;
fix_insert.cpp:  // randomize insertion positions and set v, omega
fix_insert.cpp:  // returns # bodies and # spheres that could actually be inserted
fix_insert.cpp:  x_v_omega(ninsert_this_local,ninserted_this_local,ninserted_spheres_this_local,mass_inserted_this_local);
fix_insert.cpp:  // actual particle insertion
fix_insert.cpp:  fix_distribution->pre_insert(ninserted_this_local,fix_property,fix_property_value);
fix_insert.cpp:  ninserted_spheres_this_local = fix_distribution->insert(ninserted_this_local);
fix_insert.cpp:  // warn if max # insertions exceeded by random processes
fix_insert.cpp:  if (ninsert_exists && ninserted + ninsert_this > ninsert)
fix_insert.cpp:      error->warning(FLERR,"INFO: Particle insertion: Number of particles to insert was slightly exceeded by random process");
fix_insert.cpp:    atom->natoms += static_cast<double>(ninserted_spheres_this);
fix_insert.cpp:  fix_distribution->finalize_insertion();
fix_insert.cpp:  finalize_insertion(ninserted_spheres_this_local);
fix_insert.cpp:  MPI_Sum_Scalar(ninserted_this_local,ninserted_this,world);
fix_insert.cpp:  ninserted += ninserted_this;
fix_insert.cpp:  MPI_Sum_Scalar(mass_inserted_this_local,mass_inserted_this,world);
fix_insert.cpp:  massinserted += mass_inserted_this;
fix_insert.cpp:  print_stats_during(ninserted_this,mass_inserted_this);
fix_insert.cpp:  if(ninserted_this < ninsert_this && comm->me == 0)
fix_insert.cpp:      error->warning(FLERR,"Particle insertion: Less insertions than requested");
fix_insert.cpp:  // next timestep to insert
fix_insert.cpp:  if (insert_every && (!ninsert_exists || ninserted < ninsert)) next_reneighbor += insert_every;
fix_insert.cpp:   distribute insertions across processors
fix_insert.cpp:int FixInsert::distribute_ninsert_this(int ninsert_this)
fix_insert.cpp:    int me, nprocs, ngap, ninsert_this_local, *ninsert_this_local_all;
fix_insert.cpp:    fraction_local = insertion_fraction();
fix_insert.cpp:        return static_cast<int>(fraction_local*static_cast<double>(ninsert_this) + random->uniform());
fix_insert.cpp:    // for exact_number==1, have to allgather to exactly match ninsert_this
fix_insert.cpp:    ninsert_this_local_all = new int[nprocs];
fix_insert.cpp:    // proc0 calculates ninsert_this_local for all processes
fix_insert.cpp:            ninsert_this_local_all[iproc] = static_cast<int>(fraction_local_all[iproc]*static_cast<double>(ninsert_this));
fix_insert.cpp:            remainder[iproc] = fraction_local_all[iproc]*static_cast<double>(ninsert_this) - ninsert_this_local_all[iproc];
fix_insert.cpp:            ninsert_this_local_all[iproc]++;
fix_insert.cpp:    MPI_Bcast(ninsert_this_local_all,nprocs, MPI_INT,0,world);
fix_insert.cpp:    ninsert_this_local = ninsert_this_local_all[me];
fix_insert.cpp:    delete []ninsert_this_local_all;
fix_insert.cpp:    return ninsert_this_local;
fix_insert.cpp:int FixInsert::load_xnear(int ninsert_this_local)
fix_insert.cpp:          neighList.insert_superquadric(x[i], radius[i], atom->quaternion[i], atom->shape[i], atom->blockiness[i]);
fix_insert.cpp:          neighList.insert(x[i], radius[i]);
fix_insert.cpp:        neighList.insert(x[i], radius[i]);
fix_insert.cpp:      velocity[0] = v_insert[0] + v_insertFluct[0] * 2.0 * (random->uniform()-0.50);
fix_insert.cpp:      velocity[1] = v_insert[1] + v_insertFluct[1] * 2.0 * (random->uniform()-0.50);
fix_insert.cpp:      velocity[2] = v_insert[2] + v_insertFluct[2] * 2.0 * (random->uniform()-0.50);
fix_insert.cpp:      velocity[0] = v_insert[0] + v_insertFluct[0] * random->gaussian();
fix_insert.cpp:      velocity[1] = v_insert[1] + v_insertFluct[1] * random->gaussian();
fix_insert.cpp:      velocity[2] = v_insert[2] + v_insertFluct[2] * random->gaussian();
fix_insert.cpp:  list[n++] = static_cast<double>(ninserted);
fix_insert.cpp:  list[n++] = massinserted;
fix_insert.cpp:  ninserted = static_cast<int> (list[n++]);
fix_insert.cpp:  massinserted = list[n++];
fix_insert.cpp:  // if insert was already finished in run to be restarted
fix_insert.cpp:    if(index == 0) return static_cast<double>(ninserted);
fix_insert.cpp:    if(index == 1) return massinserted;
fix_insert_pack.cpp:#include "fix_insert_pack.h"
fix_insert_pack.cpp:    } else if(strcmp(style,"insert/pack") == 0)
fix_insert_pack.cpp:  // no fixed total number of particles inserted by this fix exists
fix_insert_pack.cpp:  if(strcmp(style,"insert/pack") == 0)
fix_insert_pack.cpp:    ninsert_exists = 0;
fix_insert_pack.cpp:fprintf(screen,"Fix_insert_pack is being used \n");
fix_insert_pack.cpp:      insertion_ratio = 0.;
fix_insert_pack.cpp:void FixInsertPack::calc_insertion_properties()
fix_insert_pack.cpp:        error->fix_error(FLERR,this,"must define an insertion region");
fix_insert_pack.cpp:    //  printf("Total volume of the insertion region: %e\n",region_volume);
fix_insert_pack.cpp:        error->one(FLERR,"Fix insert: Region volume calculation with MC failed");
fix_insert_pack.cpp:    // error check on insert_every
fix_insert_pack.cpp:    if(insert_every < 0)
fix_insert_pack.cpp:        error->fix_error(FLERR,this,"must define 'insert_every'");
fix_insert_pack.cpp:    if(ninsert > 0 || massinsert > 0.)
fix_insert_pack.cpp:   has to be called at initialization and before every insertion in case
fix_insert_pack.cpp:   number of particles to insert this timestep
fix_insert_pack.cpp:int FixInsertPack::calc_ninsert_this()
fix_insert_pack.cpp:  int ninsert_this = 0;
fix_insert_pack.cpp:  // get number of particles, masss and occupied volume in insertion region
fix_insert_pack.cpp:      ninsert_this = static_cast<int>((volumefraction_region*region_volume - vol_region) / fix_distribution->vol_expect() + random->uniform());
fix_insert_pack.cpp:      insertion_ratio = vol_region / (volumefraction_region*region_volume);
fix_insert_pack.cpp:      ninsert_this = ntotal_region - np_region;
fix_insert_pack.cpp:      insertion_ratio = static_cast<double>(np_region) / static_cast<double>(ntotal_region);
fix_insert_pack.cpp:      ninsert_this = static_cast<int>((masstotal_region - mass_region) / fix_distribution->mass_expect() + random->uniform());
fix_insert_pack.cpp:      insertion_ratio = mass_region / masstotal_region;
fix_insert_pack.cpp:  else error->one(FLERR,"Internal error in FixInsertPack::calc_ninsert_this()");
fix_insert_pack.cpp:  //  printf("Target number of particles to be inserted: %d\n", ninsert_this);
fix_insert_pack.cpp:  if(ninsert_this < -200000)
fix_insert_pack.cpp:    error->fix_error(FLERR,this,"overflow in particle number calculation: inserting too many particles in one step");
fix_insert_pack.cpp:  if(ninsert_this < 0) ninsert_this = 0;
fix_insert_pack.cpp:  if(insertion_ratio < 0.) insertion_ratio = 0.;
fix_insert_pack.cpp:  if(insertion_ratio > 1.) insertion_ratio = 1.;
fix_insert_pack.cpp:  return ninsert_this;
fix_insert_pack.cpp:double FixInsertPack::insertion_fraction()
fix_insert_pack.cpp:   propertional to total desired # of particles to insert on this
fix_insert_pack.cpp:   subdomain to ensure insertion "does not give up too early" if a low
fix_insert_pack.cpp:   remaining # of insertions is to be performed
fix_insert_pack.cpp:int FixInsertPack::calc_maxtry(int ninsert_this_local)
fix_insert_pack.cpp:    if(insertion_ratio >= 1.) return ninsert_this_local * maxattempt;
fix_insert_pack.cpp:    else return static_cast<int>( static_cast<double>(ninsert_this_local*maxattempt) / (1.-insertion_ratio));
fix_insert_pack.cpp:   generate random positions within insertion volume
fix_insert_pack.cpp:   returns # bodies and # spheres that could actually be inserted
fix_insert_pack.cpp:void FixInsertPack::x_v_omega(int ninsert_this_local,int &ninserted_this_local, int &ninserted_spheres_this_local, double &mass_inserted_this_local)
fix_insert_pack.cpp:    ninserted_this_local = ninserted_spheres_this_local = 0;
fix_insert_pack.cpp:    mass_inserted_this_local = 0.;
fix_insert_pack.cpp:    int maxtry = calc_maxtry(ninsert_this_local);
fix_insert_pack.cpp:        for(int itotal = 0; itotal < ninsert_this_local; itotal++)
fix_insert_pack.cpp:            pti = fix_distribution->pti_list[ninserted_this_local];
fix_insert_pack.cpp:            if(screen && print_stats_during_flag && (ninsert_this_local >= 10) && (0 == itotal % (ninsert_this_local/10)))
fix_insert_pack.cpp:                fprintf(screen,"insertion: proc %d at %d %%\n",comm->me,10*itotal/(ninsert_this_local/10));
fix_insert_pack.cpp:            vectorCopy3D(v_insert,v_toInsert);
fix_insert_pack.cpp:                MathExtraLiggghts::random_unit_quat(random,quat_insert);
fix_insert_pack.cpp:            ninserted_spheres_this_local += pti->set_x_v_omega(pos,v_toInsert,omega_insert,quat_insert);
fix_insert_pack.cpp:            mass_inserted_this_local += pti->mass_ins;
fix_insert_pack.cpp:            ninserted_this_local++;
fix_insert_pack.cpp:        while(ntry < maxtry && ninserted_this_local < ninsert_this_local)
fix_insert_pack.cpp:            pti = fix_distribution->pti_list[ninserted_this_local];
fix_insert_pack.cpp:            if(screen && print_stats_during_flag && (ninsert_this_local >= 10) && (0 == ninserted_this_local % (ninsert_this_local/10)) )
fix_insert_pack.cpp:                fprintf(screen,"insertion: proc %d at %d %%\n",comm->me,10*ninserted_this_local/(ninsert_this_local/10));
fix_insert_pack.cpp:                vectorCopy3D(v_insert,v_toInsert);
fix_insert_pack.cpp:                    MathExtraLiggghts::random_unit_quat(random,quat_insert);
fix_insert_pack.cpp:                nins = pti->check_near_set_x_v_omega(pos,v_toInsert,omega_insert,quat_insert,neighList);
fix_insert_pack.cpp:                ninserted_spheres_this_local += nins;
fix_insert_pack.cpp:                mass_inserted_this_local += pti->mass_ins;
fix_insert_pack.cpp:                ninserted_this_local++;
fix_insert_rate_region.cpp:#include "fix_insert_rate_region.h"
fix_insert_rate_region.cpp:    } else if(strcmp(style,"insert/rate/region") == 0)
fix_insert_rate_region.cpp:fprintf(screen,"Fix_insert_rate is being used \n");
fix_insert_rate_region.cpp:void FixInsertRateRegion::calc_insertion_properties()
fix_insert_rate_region.cpp:        error->fix_error(FLERR,this,"must define an insertion region");
fix_insert_rate_region.cpp:        error->one(FLERR,"Fix insert: Region volume calculation with MC failed");
fix_insert_rate_region.cpp:    // error check on insert_every
fix_insert_rate_region.cpp:    if(insert_every < 0)
fix_insert_rate_region.cpp:        error->fix_error(FLERR,this,"must define 'insert_every'");
fix_insert_rate_region.cpp:    if(insert_every == 0)
fix_insert_rate_region.cpp:        error->fix_error(FLERR,this,"'insert_every' = once not allowed");
fix_insert_rate_region.cpp:    if(ninsert > 0 && massinsert > 0.)
fix_insert_rate_region.cpp:    // ninsert - either defined defined directly or calculated
fix_insert_rate_region.cpp:    if(ninsert == 0&& ninsert_exists)
fix_insert_rate_region.cpp:        if(massinsert > 0.) ninsert = static_cast<int>(massinsert / fix_distribution->mass_expect());
fix_insert_rate_region.cpp:    // flow rate, ninsert_per
fix_insert_rate_region.cpp:    ninsert_per = nflowrate*(static_cast<double>(insert_every)*dt);
fix_insert_rate_region.cpp:    if(ninsert_exists) massinsert = static_cast<double>(ninsert) * fix_distribution->mass_expect();
fix_insert_rate_region.cpp:int FixInsertRateRegion::calc_ninsert_this()
fix_insert_rate_region.cpp:  return FixInsert::calc_ninsert_this();
fix_insert_rate_region.cpp:   calc # of maximum tries - directly linked to number of particles to insert
fix_insert_rate_region.cpp:int FixInsertRateRegion::calc_maxtry(int ninsert_this_local)
fix_insert_rate_region.cpp:    return ninsert_this_local * maxattempt;
fix_insert_stream.cpp:#include "fix_insert_stream.h"
fix_insert_stream.cpp:    if (strcmp(arg[iarg],"insertion_face") == 0)
fix_insert_stream.cpp:    else if (0 == strcmp(style,"insert/stream")) 
fix_insert_stream.cpp:fprintf(screen,"fix_insert_stream is being used \n");
fix_insert_stream.cpp:    // only register property if I am the first fix/insert/stream in the simulation
fix_insert_stream.cpp:        fixarg[0]="release_fix_insert_stream";
fix_insert_stream.cpp:        fixarg[3]="release_fix_insert_stream";
fix_insert_stream.cpp:        fix_release = static_cast<FixPropertyAtom*>(modify->find_fix_property("release_fix_insert_stream","property/atom","vector",14,0,style));
fix_insert_stream.cpp:        if(!fix_release) error->fix_error(FLERR,this,"Internal error in fix insert/stream");
fix_insert_stream.cpp:        fix_template_ = static_cast<FixPropertyAtom*>(modify->find_fix_property("insertion_template_", "property/atom", "scalar", 1, 0, style, false));
fix_insert_stream.cpp:            fixarg[0] = "insertion_template_";
fix_insert_stream.cpp:            fixarg[3] = "insertion_template_";
fix_insert_stream.cpp:        modify->delete_fix("release_fix_insert_stream");
fix_insert_stream.cpp:   calculate ninsert, insert_every, ninsert_per, massinsert, flowrates etc
fix_insert_stream.cpp:void FixInsertStream::calc_insertion_properties()
fix_insert_stream.cpp:    // error check on insertion face
fix_insert_stream.cpp:        error->fix_error(FLERR,this,"must define an insertion face");
fix_insert_stream.cpp:    // check properties of insertion face
fix_insert_stream.cpp:            error->fix_error(FLERR,this,"command requires a planar face for insertion");
fix_insert_stream.cpp:        // flip normal vector so dot product with v_insert is > 0
fix_insert_stream.cpp:        dot = vectorDot3D(v_insert,normalvec);
fix_insert_stream.cpp:        dot = vectorDot3D(v_insert,normalvec);
fix_insert_stream.cpp:        vectorSubtract3D(v_insert,v_normal,diff);
fix_insert_stream.cpp:          error->fix_error(FLERR,this,"insertion velocity projected on face normal is < 1e-3");
fix_insert_stream.cpp:    else error->fix_error(FLERR,this,"FixInsertStream::calc_insertion_properties(): Implementation missing");
fix_insert_stream.cpp:    // error check on insertion velocity
fix_insert_stream.cpp:    if(vectorMag3D(v_insert) < 1e-5)
fix_insert_stream.cpp:        error->fix_error(FLERR,this,"insertion velocity too low");
fix_insert_stream.cpp:    if(insert_every == -1 && extrude_length == 0.)
fix_insert_stream.cpp:      error->fix_error(FLERR,this,"must define either 'insert_every' or 'extrude_length'");
fix_insert_stream.cpp:    if(insert_every > -1 && extrude_length > 0.)
fix_insert_stream.cpp:      error->fix_error(FLERR,this,"must not provide both 'insert_every' and 'extrude_length'");
fix_insert_stream.cpp:    // if extrude_length given, calculate insert_every
fix_insert_stream.cpp:    if(insert_every == -1)
fix_insert_stream.cpp:        insert_every = static_cast<int>((extrude_length+FIX_INSERT_STREAM_TINY)/(dt*vectorMag3D(v_normal)));
fix_insert_stream.cpp:        if(insert_every == 0)
fix_insert_stream.cpp:          error->fix_error(FLERR,this,"insertion velocity too high or extrude_length too low");
fix_insert_stream.cpp:    // if insert_every given, calculate extrude_length
fix_insert_stream.cpp:    // take into account duration can be != insert_every
fix_insert_stream.cpp:        if(insert_every < 1) error->fix_error(FLERR,this,"'insert_every' must be > 0");
fix_insert_stream.cpp:        // duration = insert_every by default (if already > 0, defined directly)
fix_insert_stream.cpp:        if(duration == 0) duration = insert_every;
fix_insert_stream.cpp:        else if (duration > insert_every) error->fix_error(FLERR,this,"'duration' > 'insert_every' not allowed");
fix_insert_stream.cpp:          error->fix_error(FLERR,this,"'insert_every' or 'vel' is too small, or (bounding) radius of inserted particles too large");
fix_insert_stream.cpp:    // ninsert - if ninsert not defined directly, calculate it
fix_insert_stream.cpp:    if(ninsert == 0 && ninsert_exists)
fix_insert_stream.cpp:        if(massinsert/fix_distribution->mass_expect() > 2.e9)
fix_insert_stream.cpp:           error->fix_error(FLERR,this,"you are attempting to insert more than 2e9 particles. Reduce the mass to be inserted or increase the particle diameter");
fix_insert_stream.cpp:        if(massinsert > 0.) ninsert = static_cast<int>((massinsert+FIX_INSERT_STREAM_TINY) / fix_distribution->mass_expect());
fix_insert_stream.cpp:    // ninsert_per and massinsert
fix_insert_stream.cpp:    ninsert_per = nflowrate*(static_cast<double>(insert_every)*dt);
fix_insert_stream.cpp:    if(ninsert_exists) massinsert = static_cast<double>(ninsert) * fix_distribution->mass_expect();
fix_insert_stream.cpp:    else error->fix_error(FLERR,this,"Missing implementation in calc_insertion_properties()");
fix_insert_stream.cpp:        error->fix_error(FLERR,this,"Currently only fix insert/stream with multisphere particles only supports constant velocity");
fix_insert_stream.cpp:    fix_release = static_cast<FixPropertyAtom*>(modify->find_fix_property("release_fix_insert_stream","property/atom","vector",5,0,style));
fix_insert_stream.cpp:    if(!fix_release) error->fix_error(FLERR,this,"Internal error if fix insert/stream");
fix_insert_stream.cpp:    // error check on insertion face
fix_insert_stream.cpp:        error->fix_error(FLERR,this,"must define an insertion face");
fix_insert_stream.cpp:        error->fix_error(FLERR,this,"cannot translate, rotate, scale mesh which is used for particle insertion");
fix_insert_stream.cpp:double FixInsertStream::insertion_fraction()
fix_insert_stream.cpp:    // have to re-calculate insertion fraction for my subbox
fix_insert_stream.cpp:   calculate insertion fraction for my subbox
fix_insert_stream.cpp:   has to be called at initialization and before every insertion in case
fix_insert_stream.cpp:    // this can speed up insertion if extrusion volume extends across multiple procs
fix_insert_stream.cpp:        error->fix_error(FLERR,this,"insertion volume could not be distributed properly in parallel. "
fix_insert_stream.cpp:                                     "Bad decomposition or insertion face extrusion is too small or outside domain");
fix_insert_stream.cpp:bool FixInsertStream::pre_insert()
fix_insert_stream.cpp:      error->warning(FLERR,"Fix insert/stream: Extruded insertion face extends outside domain, may not insert all particles correctly");
fix_insert_stream.cpp:   generate random positions on insertion face
fix_insert_stream.cpp:   generate random positions on shallow copy insertion face
fix_insert_stream.cpp:   returns # bodies and # spheres that could actually be inserted
fix_insert_stream.cpp:void FixInsertStream::x_v_omega(int ninsert_this_local,int &ninserted_this_local, int &ninserted_spheres_this_local, double &mass_inserted_this_local)
fix_insert_stream.cpp:    ninserted_this_local = ninserted_spheres_this_local = 0;
fix_insert_stream.cpp:    mass_inserted_this_local = 0.;
fix_insert_stream.cpp:    int maxtry = ninsert_this_local * maxattempt;
fix_insert_stream.cpp:    // insert with v_normal, no omega
fix_insert_stream.cpp:        for(int itotal = 0; itotal < ninsert_this_local; itotal++)
fix_insert_stream.cpp:            pti = fix_distribution->pti_list[ninserted_this_local];
fix_insert_stream.cpp:            double rad_to_insert = pti->r_bound_ins;
fix_insert_stream.cpp:                generate_random(pos,rad_to_insert);
fix_insert_stream.cpp:                        MathExtraLiggghts::random_unit_quat(random,quat_insert);
fix_insert_stream.cpp:                nins = pti->set_x_v_omega(pos,v_normal,omega_tmp,quat_insert);
fix_insert_stream.cpp:                ninserted_spheres_this_local += nins;
fix_insert_stream.cpp:                mass_inserted_this_local += pti->mass_ins;
fix_insert_stream.cpp:                ninserted_this_local++;
fix_insert_stream.cpp:        while(ntry < maxtry && ninserted_this_local < ninsert_this_local)
fix_insert_stream.cpp:            pti = fix_distribution->pti_list[ninserted_this_local];
fix_insert_stream.cpp:            double rad_to_insert = pti->r_bound_ins;
fix_insert_stream.cpp:                    generate_random(pos,rad_to_insert);
fix_insert_stream.cpp:                while(ntry < maxtry && ((!domain->is_in_subdomain(pos)) || (domain->dist_subbox_borders(pos) < rad_to_insert)));
fix_insert_stream.cpp:                        MathExtraLiggghts::random_unit_quat(random,quat_insert);
fix_insert_stream.cpp:                    nins = pti->check_near_set_x_v_omega(pos,v_normal,omega_tmp,quat_insert,neighList);
fix_insert_stream.cpp:                ninserted_spheres_this_local += nins;
fix_insert_stream.cpp:                mass_inserted_this_local += pti->mass_ins;
fix_insert_stream.cpp:                ninserted_this_local++;
fix_insert_stream.cpp:void FixInsertStream::finalize_insertion(int ninserted_spheres_this_local)
fix_insert_stream.cpp:    // nins particles have been inserted on this proc, set initial position, insertion step and release step according to pos
fix_insert_stream.cpp:    int ilo = atom->nlocal - ninserted_spheres_this_local;
fix_insert_stream.cpp:        // 4th value is insertion step
fix_insert_stream.cpp:        vectorCopy3D(v_insert,v_toInsert);
fix_insert_stream.cpp:        vectorCopy3D(omega_insert,omega_toInsert);
fix_insert_stream.cpp:            // step < r_step, only true for inserted particles
fix_insert_stream.cpp:        // 4th value is insertion step
fix_massflow_mesh.cpp:                error->fix_error(FLERR,this,"not enough arguments for 'insert_stream'");
fix_massflow_mesh.cpp:                error->fix_error(FLERR,this,"not enough arguments for 'insert_stream'");
fix_mesh_surface.cpp:            module_restrict_map->insert( std::pair<std::string, std::vector<std::string> >(#key1, std::vector<std::string>(1,#key2))); \
fix_mesh_surface.cpp:            module_restrict_map->insert( std::pair<std::string, std::vector<std::string> >(#key2, std::vector<std::string>(1,#key1)));
fix_mesh_surface.cpp:            active_mesh_modules.insert(std::pair<std::string, MeshModule*>(line, mm_creator(lmp, iarg_, narg, arg, this)));
fix_multisphere.cpp:    int n_stream = modify->n_fixes_style("insert/stream");
fix_multisphere.cpp:  int n_stream = modify->n_fixes_style("insert/stream");
fix_particledistribution_discrete.cpp:  // sort the distributions by insertion volume (in descending order)
fix_particledistribution_discrete.cpp:   typically called once per insertion step
fix_particledistribution_discrete.cpp:    ninsert = ntotal;
fix_particledistribution_discrete.cpp:    ninserted = 0;
fix_particledistribution_discrete.cpp:       parttogen[i] = static_cast<int>(static_cast<double>(ninsert) * distweight[i] + random->uniform());
fix_particledistribution_discrete.cpp:    ninsert = 0;
fix_particledistribution_discrete.cpp:        ninsert += parttogen[i];
fix_particledistribution_discrete.cpp:    return ninsert;
fix_particledistribution_discrete.cpp:    int ntoinsert = parttogen[chosendist];
fix_particledistribution_discrete.cpp:    while(ninserted >= ntoinsert && chosen < ntemplates-1)
fix_particledistribution_discrete.cpp:        ntoinsert += parttogen[chosendist];
fix_particledistribution_discrete.cpp:    ninserted++;
fix_particledistribution_discrete.cpp:   typically only called once before first insertion step
fix_particledistribution_discrete.cpp:   can be called by multiple fix insert commands, so check first if max #
fix_particledistribution_discrete.cpp:   particles to be inserted is exceeded and only re-allocate in this case
fix_particledistribution_discrete.cpp:   the list in this fix. returns number of particles to be inserted.
fix_particledistribution_discrete.cpp:   typically called once per insertion step
fix_particledistribution_discrete.cpp:int FixParticledistributionDiscrete::randomize_list(int ntotal,int insert_groupbit,int exact_number)
fix_particledistribution_discrete.cpp:    ninsert = ntotal;
fix_particledistribution_discrete.cpp:    ninserted = 0;
fix_particledistribution_discrete.cpp:    // use random generator so long-time average of insertion will represent distribution correctly
fix_particledistribution_discrete.cpp:           parttogen[i] = static_cast<int>(static_cast<double>(ninsert) * distweight[i] + random->uniform());
fix_particledistribution_discrete.cpp:    // truncate distribution so # particles to insert is met exactly
fix_particledistribution_discrete.cpp:        int ninsert_truncated = 0, j;
fix_particledistribution_discrete.cpp:           parttogen[i] = static_cast<int>(static_cast<double>(ninsert) * distweight[i]);
fix_particledistribution_discrete.cpp:           ninsert_truncated += parttogen[i];
fix_particledistribution_discrete.cpp:           remainder[i] = static_cast<double>(ninsert) * distweight[i] - static_cast<double>(parttogen[i]);
fix_particledistribution_discrete.cpp:        int ninsert_gap = ninsert - ninsert_truncated;
fix_particledistribution_discrete.cpp:        // distribute remaining ninsert_gap particles
fix_particledistribution_discrete.cpp:        for(int i = 0; i < ninsert_gap; i++)
fix_particledistribution_discrete.cpp:            r = random->uniform() * static_cast<double>(ninsert_gap);
fix_particledistribution_discrete.cpp:    // count total particle number to be inserted, let templates generate a pti_list
fix_particledistribution_discrete.cpp:    ninsert = 0;
fix_particledistribution_discrete.cpp:        ninsert += parttogen[i];
fix_particledistribution_discrete.cpp:        templates[i]->randomize_ptilist(parttogen[i],groupbit | insert_groupbit,distorder[i]);
fix_particledistribution_discrete.cpp:    if(n_pti != ninsert)
fix_particledistribution_discrete.cpp:    ninserted = ninsert;
fix_particledistribution_discrete.cpp:    return ninsert;
fix_particledistribution_discrete.cpp:    ninsert = 0;
fix_particledistribution_discrete.cpp:        ninsert += ext_parttogen[i];
fix_particledistribution_discrete.cpp:    if(n_pti != ninsert)
fix_particledistribution_discrete.cpp:    ninserted = ninsert;
fix_particledistribution_discrete.cpp:    return ninsert;
fix_particledistribution_discrete.cpp:   preparations before insertion
fix_particledistribution_discrete.cpp:void FixParticledistributionDiscrete::pre_insert(int n,class FixPropertyAtom *fp,double val)
fix_particledistribution_discrete.cpp:    // set_arrays called in ParticleToInsert::insert()
fix_particledistribution_discrete.cpp:    // set fix property as desired by fix insert
fix_particledistribution_discrete.cpp:              error->one(FLERR,"'bonded' and setting values for a fix property upon insertion can not be used together");
fix_particledistribution_discrete.cpp:   loop to n, not n_pti, since not all particles may have been inserted
fix_particledistribution_discrete.cpp:int FixParticledistributionDiscrete::insert(int n)
fix_particledistribution_discrete.cpp:    int ninserted_spheres_local = 0;
fix_particledistribution_discrete.cpp:        ninserted_spheres_local += pti_list[i]->insert();
fix_particledistribution_discrete.cpp:    return ninserted_spheres_local;
fix_particledistribution_discrete.cpp:   wrap up insertion
fix_particledistribution_discrete.cpp:void FixParticledistributionDiscrete::finalize_insertion()
fix_particledistribution_discrete.cpp:        templates[i]->finalize_insertion();
fix_property_atom_tracer_stream.cpp:#include "fix_insert_stream.h"
fix_property_atom_tracer_stream.cpp:        else if(strcmp(arg[iarg_],"insert_stream") == 0) {
fix_property_atom_tracer_stream.cpp:                error->fix_error(FLERR,this,"not enough arguments for 'insert_stream'");
fix_property_atom_tracer_stream.cpp:            fix_ins_stream_ = static_cast<FixInsertStream*>(modify->find_fix_id_style(arg[iarg_++],"insert/stream"));
fix_property_atom_tracer_stream.cpp:                error->fix_error(FLERR,this,"insert_stream ID does not exist");
fix_property_atom_tracer_stream.cpp:            error->fix_error(FLERR,this,"expecting keyword 'insert_stream'");
fix_template_multiplespheres.cpp:            pti_list[i]->fix_property_value[0][0] = static_cast<double>(update->ntimestep)+random_insertion->uniform();
fix_template_multiplespheres.cpp:    // init insertion position
fix_template_multisphere.cpp:void FixTemplateMultisphere::finalize_insertion()
fix_template_multisphere.cpp:        error->fix_error(FLERR,this,"Multi-sphere particle inserted: You have to use exactly one fix multisphere");
fix_template_sphere.cpp:    random_insertion(NULL),
fix_template_sphere.cpp:    seed_insertion(0),
fix_template_sphere.cpp:  random_insertion = new RanPark(lmp, arg[3], true);
fix_template_sphere.cpp:  seed_insertion = random_insertion->getSeed();
fix_template_sphere.cpp:  seed_orig = seed_insertion;
fix_template_sphere.cpp:    delete random_insertion;
fix_template_sphere.cpp:    double radius = rand(pdf_radius,random_insertion);
fix_template_sphere.cpp:    pti->density_ins = rand(pdf_density,random_insertion);
fix_template_sphere.cpp:    // init insertion position
fix_template_sphere.cpp:        double radius = rand(pdf_radius,random_insertion);
fix_template_sphere.cpp:        pti_list[i]->density_ins = rand(pdf_density,random_insertion);
fix_template_sphere.cpp:        // init insertion position
fix_template_sphere.cpp:        error->one(FLERR, "Ensure that set_property is not used in fix insert");
fix_template_sphere.cpp:    // init insertion position
fix_template_sphere.cpp:  int *state_insertion_all_0 = 0;
fix_template_sphere.cpp:  int state_insertion_me = random_insertion->state();
fix_template_sphere.cpp:  int size_state_insertion_all_0 = MPI_Gather0_Vector<int>(&state_insertion_me,1,state_insertion_all_0,world);
fix_template_sphere.cpp:    if(size_state_insertion_all_0 != nprocs)
fix_template_sphere.cpp:      list[n++] = static_cast<double>(state_insertion_all_0[iproc]);
fix_template_sphere.cpp:  if(state_insertion_all_0) delete []state_insertion_all_0;
fix_template_sphere.cpp:    seed_insertion = static_cast<int> (list[me+1]);
fix_template_sphere.cpp:      seed_insertion = static_cast<int> (list[me+1]);
fix_template_sphere.cpp:      seed_insertion = static_cast<int> (list[(me%nprocs_old)+1]);
fix_template_sphere.cpp:  random_insertion->reset(seed_insertion);
fix_template_superquadric.cpp:      shape[0] = rand(pdf_shapex, random_insertion);
fix_template_superquadric.cpp:      shape[1] = rand(pdf_shapey, random_insertion);
fix_template_superquadric.cpp:      shape[2] = rand(pdf_shapez, random_insertion);
fix_template_superquadric.cpp:      double particle_size = 0.5*rand(pdf_size, random_insertion);
fix_template_superquadric.cpp:    double blockiness[] = { rand(pdf_blockiness1, random_insertion),
fix_template_superquadric.cpp:                           rand(pdf_blockiness2, random_insertion)};
fix_template_superquadric.cpp:    pti->density_ins = rand(pdf_density,random_insertion);
fix_template_superquadric.cpp:    // init insertion position
fix_template_superquadric.cpp:          shape[0] = rand(pdf_shapex, random_insertion);
fix_template_superquadric.cpp:          shape[1] = rand(pdf_shapey, random_insertion);
fix_template_superquadric.cpp:          shape[2] = rand(pdf_shapez, random_insertion);
fix_template_superquadric.cpp:          double particle_size = 0.5*rand(pdf_size, random_insertion);
fix_template_superquadric.cpp:        double blockiness[] = { rand(pdf_blockiness1, random_insertion),
fix_template_superquadric.cpp:                               rand(pdf_blockiness2, random_insertion) };
fix_template_superquadric.cpp:        pti_list[i]->density_ins = rand(pdf_density,random_insertion);
fix_template_superquadric.cpp:        // init insertion position
fix_template_superquadric.cpp:        error->one(FLERR, "Ensure that set_property is not used in fix insert");
fix_template_superquadric.cpp:    // init insertion position
fix_template_superquadric.cpp:    unsigned int start = seed_insertion*420001; // it's magic
input.cpp:   parse copy of command line by inserting string terminators
input.cpp:  // nextword() inserts string terminators into copy string to delimit args
input.cpp:   insert 0 at end of word
input.cpp:  // nextword() inserts string terminators into copy string to delimit args
library.cpp:  // use atom ID to insert each atom's values into copy
library.cpp:  // use atom ID to insert each atom's values into copy
modify.cpp:    if (strncmp(fix[ifix]->style,"insert/",7) == 0)
modify.cpp:      error->all(FLERR,"Using a fix insert/* ID twice, which is not possible. Please use different ID");
multisphere.cpp:  // nobody = # of atoms newly inserted with no body associated (body = -2)
multisphere.cpp:  // nobody_check = # of atoms that should be newly inserted
pair_sph.cpp:// XXX: .. inserted in pair_sph.h
particleToInsert.cpp:int ParticleToInsert::insert()
particleToInsert.cpp:    // perform the actual insertion
particleToInsert.cpp:    int inserted = 0;
particleToInsert.cpp:                inserted++;
particleToInsert.cpp:                // apply fix property setting coming from fix insert
particleToInsert.cpp:    return inserted;
particleToInsert.cpp:    // x is position where insertion should take place
particleToInsert.cpp:    // v and omega are the velocity and omega for the newly inserted particles
particleToInsert.cpp:    // check insertion position, take quat into account
particleToInsert.cpp:    neighList.insert(x_ins[0], radius_ins[0]);
particleToInsert.cpp:    // x is position where insertion should take place
particleToInsert.cpp:    // v and omega are the velocity and omega for the newly inserted particles
particleToInsert.cpp:    // check insertion position, take quat into account
particleToInsert.cpp:        neighList.insert(x_ins[j], radius_ins[j]);
particleToInsert.cpp:    // x is position where insertion should take place
particleToInsert.cpp:    // v and omega are the velocity and omega for the newly inserted particles
particleToInsert.cpp:    // add insertion position
particleToInsert_multisphere.cpp:        neighList.insert(x_ins[j], radius_ins[j]);
particleToInsert_multisphere.cpp:int ParticleToInsertMultisphere::insert()
particleToInsert_multisphere.cpp:    int inserted = 0;
particleToInsert_multisphere.cpp:    // perform the actual particle insertion
particleToInsert_multisphere.cpp:            inserted++;
particleToInsert_multisphere.cpp:    // now rigid body insertion
particleToInsert_multisphere.cpp:        error->one(FLERR,"Multi-sphere particle inserted: You have to use exactly one fix multisphere.");
particleToInsert_multisphere.cpp:    return inserted;
particleToInsertSuperquadric.cpp:int ParticleToInsertSuperquadric::insert()
particleToInsertSuperquadric.cpp:    // perform the actual insertion
particleToInsertSuperquadric.cpp:    int inserted = 0;
particleToInsertSuperquadric.cpp:                inserted++;
particleToInsertSuperquadric.cpp:    return inserted;
particleToInsertSuperquadric.cpp:    neighList.insert_superquadric(x_ins[0], radius_ins[0], quat_ins, shape_ins, blockiness_ins);
properties.cpp:  // such as fix insert, fix change/type, fix wall, fix pour
properties.cpp:  // such as fix insert, fix change/type, fix wall, fix pour
properties.cpp:  // such as fix insert, fix change/type, fix wall, fix pour
reader_xyz.cpp:    // XXX: we could insert an element2type translation here
region.cpp:                         "   (b) particles for insertion are too large when using all_in yes\n"
region.cpp:                         "   (b) particles for insertion are too large when using all_in yes\n"
region_mesh_tet.cpp:        neighList.insert(center[i], rbound[i],i);
